// .github/scripts/implementer.js
// Node 20+ (fetch is built-in).
// Flow:
// - Validate label 'spec'
// - Build prompt from Issue body
// - Call Anthropic (Claude Sonnet 4 by default)
// - Write <<<file:...>>> blocks
// - Save <<<commands>>> to commands.txt (optional)
// - Commit, push branch, open PR

const fs = require("fs");
const cp = require("child_process");
const path = require("path");

async function callAnthropic(prompt) {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) throw new Error("Missing ANTHROPIC_API_KEY");
  // Allow override via secret/variable; default to Claude Sonnet 4 (May 2025 build)
  const model = process.env.ANTHROPIC_MODEL || "claude-sonnet-4-20250514";

  const res = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "x-api-key": apiKey,
      "anthropic-version": "2023-06-01",
      "content-type": "application/json",
    },
    body: JSON.stringify({
      model,
      max_tokens: 4096,
      messages: [{ role: "user", content: prompt }],
    }),
  });

  if (res.status === 404) {
    // Fallback op robuuste 3.5/3.7 indien Sonnet 4 niet beschikbaar is op jouw account
    const fallback = "claude-3-5-sonnet-20241022";
    const res2 = await fetch("https://api.anthropic.com/v1/messages", {
      method: "POST",
      headers: {
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01",
        "content-type": "application/json",
      },
      body: JSON.stringify({
        model: fallback,
        max_tokens: 4096,
        messages: [
          { role: "user", content: prompt + `\n\n(Using fallback model: ${fallback})` },
        ],
      }),
    });
    if (!res2.ok) {
      const text = await res2.text();
      throw new Error(`Anthropic fallback failed: ${res2.status} ${text}`);
    }
    return res2.json();
  }

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Anthropic request failed: ${res.status} ${text}`);
  }
  return res.json();
}

function parseAnthropicTextPayload(data) {
  // Anthropic v1/messages returns { content: [{type:'text', text:'...'}, ...], ... }
  const parts = Array.isArray(data.content) ? data.content : [];
  const text = parts
    .filter((p) => p && p.type === "text" && typeof p.text === "string")
    .map((p) => p.text)
    .join("");
  return text;
}

function writeFilesFromBlocks(text) {
  const fileRegex = /<<<file:(.+?)>>>\n([\s\S]*?)\n<<<endfile>>>/g;
  let m, count = 0;
  while ((m = fileRegex.exec(text)) !== null) {
    const relPath = m[1].trim();
    const code = m[2];
    const full = path.resolve(process.cwd(), relPath);
    fs.mkdirSync(path.dirname(full), { recursive: true });
    fs.writeFileSync(full, code, "utf8");
    count++;
    console.log("Wrote:", relPath);
  }
  const cmdMatch = text.match(/<<<commands>>>\n([\s\S]*?)\n<<<endcommands>>>/);
  fs.writeFileSync("commands.txt", cmdMatch ? cmdMatch[1] : "", "utf8");
  return count;
}

async function openPullRequest(issueNumber, branch) {
  const repo = process.env.GITHUB_REPOSITORY; // "owner/repo"
  const token = process.env.GITHUB_TOKEN;
  if (!repo) throw new Error("Missing GITHUB_REPOSITORY");
  if (!token) throw new Error("Missing GITHUB_TOKEN");

  const [owner, repoName] = repo.split("/");

  // Get default branch
  const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}`, {
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
    },
  });
  if (!repoRes.ok) throw new Error(`Repo fetch failed: ${repoRes.status}`);
  const repoJson = await repoRes.json();
  const base = repoJson.default_branch || "main";

  const prRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/pulls`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
    },
    body: JSON.stringify({
      title: `AI: SC #${issueNumber}`,
      head: branch,
      base,
      body: "Auto-generated by Implementer",
    }),
  });
  if (!prRes.ok) {
    const txt = await prRes.text();
    throw new Error(`PR create failed: ${prRes.status} ${txt}`);
  }
  const pr = await prRes.json();
  console.log(`PR opened: #${pr.number} ${pr.html_url}`);
}

async function main() {
  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (!eventPath) throw new Error("Missing GITHUB_EVENT_PATH");

  const payload = JSON.parse(fs.readFileSync(eventPath, "utf8"));
  const issue = payload.issue;
  if (!issue || !issue.body) {
    console.log("No issue body present — nothing to do.");
    return;
  }

  const labels = (issue.labels || []).map((l) => l.name || l);
  if (!labels.includes("spec")) {
    console.log("Issue does not have 'spec' label — skipping.");
    return;
  }
  const issueNumber = issue.number;
  const spec = issue.body;

  const prompt = `
You are Claude Code. Implement the SPEC CARD by returning a set of files with this exact format:

<<<file:relative/path>>>
...code...
<<<endfile>>>

(Repeat per file)
Then a section:
<<<commands>>>
one shell command per line
<<<endcommands>>>

NO explanations. SPEC:

${spec}
`.trim();

  // Call Anthropic
  const data = await callAnthropic(prompt);
  const text = parseAnthropicTextPayload(data);

  if (!text || !text.includes("<<<file:")) {
    fs.writeFileSync("claude_out.txt", text || "");
    throw new Error(
      "No <<<file:...>>> blocks returned by Anthropic. See claude_out.txt for raw output."
    );
  }

  // Write files from blocks
  const count = writeFilesFromBlocks(text);
  if (!count) {
    console.log("No files were written from Anthropic output.");
    return;
  }

  // If nothing changed, stop
  const status = cp.execSync("git status --porcelain", { encoding: "utf8" }).trim();
  if (!status) {
    console.log("No changes to commit.");
    return;
  }

  // Commit & push branch
  const branch = `auto/sc-${issueNumber}`;
  cp.execSync('git config user.name "ai-implementer"', { stdio: "inherit" });
  cp.execSync('git config user.email "bot@users.noreply.github.com"', { stdio: "inherit" });
  cp.execSync(`git checkout -b "${branch}"`, { stdio: "inherit" });
  cp.execSync("git add -A", { stdio: "inherit" });
  cp.execSync(`git commit -m "AI: implement SC-${issueNumber}"`, { stdio: "inherit" });
  cp.execSync(`git push -u origin "${branch}"`, { stdio: "inherit" });

  // Open PR
  await openPullRequest(issueNumber, branch);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
