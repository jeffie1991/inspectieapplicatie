// .github/scripts/implementer.js
// Node 20+ (fetch built-in). Does:
// - Validate label 'spec'
// - Build prompt from Issue body
// - Call Anthropic
// - Write <<<file:...>>> blocks to repo
// - Commit, push branch, open PR via GitHub API

const fs = require("fs");
const cp = require("child_process");

async function main() {
  const repo = process.env.GITHUB_REPOSITORY; // "owner/repo"
  const token = process.env.GITHUB_TOKEN;
  const anthropicKey = process.env.ANTHROPIC_API_KEY;
  const eventPath = process.env.GITHUB_EVENT_PATH;

  if (!eventPath) throw new Error("Missing GITHUB_EVENT_PATH");
  if (!token) throw new Error("Missing GITHUB_TOKEN");
  if (!anthropicKey) throw new Error("Missing ANTHROPIC_API_KEY");

  const event = JSON.parse(fs.readFileSync(eventPath, "utf8"));
  const issue = event.issue;
  if (!issue || !issue.body) throw new Error("No issue body found.");
  const labels = (issue.labels || []).map(l => l.name || l);
  if (!labels.includes("spec")) {
    console.log("Issue does not have label 'spec' â€” skipping.");
    return; // exit success (no-op)
  }
  const issueNumber = issue.number;

  const spec = issue.body;

  const prompt = `
You are Claude Code. Implement the SPEC CARD by returning a set of files with this exact format:

<<<file:relative/path>>>
...code...
<<<endfile>>>

(Repeat per file)
Then a section:
<<<commands>>>
one shell command per line
<<<endcommands>>>

NO explanations. SPEC:

${spec}
`.trim();

  // Call Anthropic
  const res = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "x-api-key": anthropicKey,
      "anthropic-version": "2023-06-01",
      "content-type": "application/json",
    },
    body: JSON.stringify({
      model: "claude-3-5-sonnet-latest",
      max_tokens: 4096,
      messages: [{ role: "user", content: prompt }],
    }),
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Anthropic request failed: ${res.status} ${text}`);
  }
  const data = await res.json();

  // Concatenate text parts
  const parts = Array.isArray(data.content) ? data.content : [];
  const text = parts
    .filter((p) => p && p.type === "text" && typeof p.text === "string")
    .map((p) => p.text)
    .join("");

  if (!text || !text.includes("<<<file:")) {
    fs.writeFileSync("claude_out.txt", text || "");
    throw new Error("No <<<file:...>>> blocks returned by Anthropic. See claude_out.txt for raw output.");
  }

  // Write files to workspace
  const fileRegex = /<<<file:(.+?)>>>\n([\s\S]*?)\n<<<endfile>>>/g;
  let m, count = 0;
  const path = require("path");
  while ((m = fileRegex.exec(text)) !== null) {
    const relPath = m[1].trim();
    const code = m[2];
    const full = path.resolve(process.cwd(), relPath);
    fs.mkdirSync(path.dirname(full), { recursive: true });
    fs.writeFileSync(full, code, "utf8");
    count++;
    console.log("Wrote:", relPath);
  }

  // Optional commands
  const cmdMatch = text.match(/<<<commands>>>\n([\s\S]*?)\n<<<endcommands>>>/);
  fs.writeFileSync("commands.txt", cmdMatch ? cmdMatch[1] : "", "utf8");

  // If nothing changed, stop
  const status = cp.execSync("git status --porcelain", { encoding: "utf8" }).trim();
  if (!status) {
    console.log("No changes to commit.");
    return;
  }

  // Git config & branch
  const branch = `auto/sc-${issueNumber}`;
  cp.execSync('git config user.name "ai-implementer"', { stdio: "inherit" });
  cp.execSync('git config user.email "bot@users.noreply.github.com"', { stdio: "inherit" });
  cp.execSync(`git checkout -b "${branch}"`, { stdio: "inherit" });
  cp.execSync("git add -A", { stdio: "inherit" });
  cp.execSync(`git commit -m "AI: implement SC-${issueNumber}"`, { stdio: "inherit" });
  cp.execSync(`git push -u origin "${branch}"`, { stdio: "inherit" });

  // Create PR using GitHub API
  const [owner, repoName] = repo.split("/");
  // Get default branch
  const repoRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}`, {
    headers: { Authorization: `Bearer ${token}`, Accept: "application/vnd.github+json" },
  });
  if (!repoRes.ok) throw new Error(`Repo fetch failed: ${repoRes.status}`);
  const repoJson = await repoRes.json();
  const base = repoJson.default_branch || "main";

  const prRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/pulls`, {
    method: "POST",
    headers: { Authorization: `Bearer ${token}`, Accept: "application/vnd.github+json" },
    body: JSON.stringify({
      title: `AI: SC #${issueNumber}`,
      head: branch,
      base,
      body: "Auto-generated by Implementer",
    }),
  });
  if (!prRes.ok) {
    const txt = await prRes.text();
    throw new Error(`PR create failed: ${prRes.status} ${txt}`);
  }
  const pr = await prRes.json();
  console.log(`PR opened: #${pr.number} ${pr.html_url}`);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
